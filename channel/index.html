<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides an mpsc (multi-producer single-consumer) channel wrapped in an `IntGauge` that counts the number of currently queued items. While there is only one `channel::Receiver`, there can be many `channel::Sender`s, which are also cheap to clone."><title>channel - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="channel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (854f22563 2025-01-31)" data-channel="nightly" data-search-js="search-2d513d54.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-302de22f.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-9b5d7e41.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../channel/index.html">channel</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>channel</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/channel/lib.rs.html#8-143">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides an mpsc (multi-producer single-consumer) channel wrapped in an
<a href="diem_metrics::IntGauge"><code>IntGauge</code></a> that counts the number of currently
queued items. While there is only one <code>channel::Receiver</code>, there can be
many <code>channel::Sender</code>s, which are also cheap to clone.</p>
<p>This channel differs from our other channel implementation,
<code>channel::diem_channel</code>, in that it is just a single queue (vs. different
queues for different keys) with backpressure (senders will block if the
queue is full instead of evicting another item in the queue) that only
implements FIFO (vs. LIFO or KLAST).</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="mod" href="diem_channel/index.html" title="mod channel::diem_channel">diem_<wbr>channel</a></dt><dd>diem_channel provides an mpsc channel which has two ends
<code>diem_channel::Receiver</code> and <code>diem_channel::Sender</code> similar to existing mpsc
data structures. What makes it different from existing mpsc channels is that
we have full control over how the internal queueing in the channel happens
and how we schedule messages to be sent out from this channel.
Internally, it uses the <code>PerKeyQueue</code> to store messages</dd><dt><a class="mod" href="message_queues/index.html" title="mod channel::message_queues">message_<wbr>queues</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Receiver.html" title="struct channel::Receiver">Receiver</a></dt><dd>An <a href="futures::channel::mpsc::Receiver"><code>mpsc::Receiver</code></a> with an [<code>IntGauge</code>]
counting the number of currently queued items.</dd><dt><a class="struct" href="struct.Sender.html" title="struct channel::Sender">Sender</a></dt><dd>An <a href="futures::channel::mpsc::Sender"><code>mpsc::Sender</code></a> with an [<code>IntGauge</code>]
counting the number of currently queued items.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="fn" href="fn.new.html" title="fn channel::new">new</a></dt><dd>Similar to <code>mpsc::channel</code>, <code>new</code> creates a pair of <code>Sender</code> and <code>Receiver</code></dd><dt><a class="fn" href="fn.new_test.html" title="fn channel::new_test">new_<wbr>test</a></dt></dl></section></div></main></body></html>