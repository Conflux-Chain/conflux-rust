<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Mempool is used to hold transactions that have been submitted but not yet agreed upon and executed."><title>cfxcore::pos::mempool - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="cfxcore" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (854f22563 2025-01-31)" data-channel="nightly" data-search-js="search-2d513d54.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-302de22f.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-9b5d7e41.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../cfxcore/index.html">cfxcore</a><span class="version">3.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module mempool</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In cfxcore::<wbr>pos</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">cfxcore</a>::<wbr><a href="../index.html">pos</a></div><h1>Module <span>mempool</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/cfxcore/pos/mempool/mod.rs.html#8-88">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Mempool is used to hold transactions that have been submitted but not yet
agreed upon and executed.</p>
<p><strong>Flow</strong>: AC sends transactions into mempool which holds them for a period
of time before sending them into consensus.  When a new transaction is
added, Mempool shares this transaction with other nodes in the system.  This
is a form of “shared mempool” in that transactions between mempools are
shared with other validators.  This helps maintain a pseudo global ordering
since when a validator receives a transaction from another mempool, it will
be ordered when added in the ordered queue of the recipient validator. To
reduce network consumption, in “shared mempool” each validator is
responsible for delivery of its own transactions (we don’t rebroadcast
transactions originated on a different peer). Also we only broadcast
transactions that have some chance to be included in next block: their
sequence number equals to the next sequence number of account or sequential
to it. For example, if the current sequence number for an account is 2 and
local mempool contains transactions with sequence numbers 2,3,4,7,8, then
only transactions 2, 3 and 4 will be broadcast.</p>
<p>Consensus pulls transactions from mempool rather than mempool pushing into
consensus. This is done so that while consensus is not yet ready for
transactions, we keep ordering based on gas and consensus can let
transactions build up.  This allows for batching of transactions into a
single consensus block as well as prioritizing by gas price. Mempool doesn’t
keep track of transactions that were sent to Consensus. On each get_block
request, Consensus additionally sends a set of transactions that were pulled
from Mempool so far but were not committed yet. This is done so Mempool can
be agnostic about different Consensus proposal branches.  Once a transaction
is fully executed and written to storage,  Consensus notifies Mempool about
it which later drops it from its internal state.</p>
<p><strong>Internals</strong>: Internally Mempool is modeled as <code>HashMap&lt;AccountAddress, AccountTransactions&gt;</code> with various indexes built on top of it. The main
index <code>PriorityIndex</code> is an ordered queue of transactions that are “ready”
to be included in next block(i.e. have sequence number sequential to current
for account). This queue is ordered by gas price so that if a client is
willing to pay more (than other clients) per unit of execution, then they
can enter consensus earlier. Note that although global ordering is
maintained by gas price, for a single account, transactions are ordered by
sequence number.</p>
<p>All transactions that are not ready to be included in the next block are
part of separate <code>ParkingLotIndex</code>. They will be moved to the ordered queue
once some event unblocks them. For example, Mempool has transaction with
sequence number 4, while current sequence number for that account is 3. Such
transaction is considered to be “non-ready”. Then callback from Consensus
notifies that transaction was committed(i.e. transaction 3 was submitted to
different node). Such event “unblocks” local transaction and txn4 will be
moved to OrderedQueue.</p>
<p>Mempool only holds a limited number of transactions to prevent OOMing the
system. Additionally there’s a limit of number of transactions per account
to prevent different abuses/attacks</p>
<p>Transactions in Mempool have two types of expirations: systemTTL and
client-specified expiration. Once we hit either of those, the transaction is
removed from Mempool. SystemTTL is checked periodically in the background,
while the client-specified expiration is checked on every Consensus commit
request. We use a separate system TTL to ensure that a transaction won’t
remain stuck in Mempool forever, even if Consensus doesn’t make progress</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="network/index.html" title="mod cfxcore::pos::mempool::network">network</a></dt><dd>Interface between Mempool and Network layers.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.CommitNotification.html" title="struct cfxcore::pos::mempool::CommitNotification">Commit<wbr>Notification</a></dt><dd>Notification from state sync to mempool of commit event.
This notifies mempool to remove committed txns.</dd><dt><a class="struct" href="struct.CommitResponse.html" title="struct cfxcore::pos::mempool::CommitResponse">Commit<wbr>Response</a></dt><dt><a class="struct" href="struct.CommittedTransaction.html" title="struct cfxcore::pos::mempool::CommittedTransaction">Committed<wbr>Transaction</a></dt><dd>Successfully executed and committed txn</dd><dt><a class="struct" href="struct.TransactionExclusion.html" title="struct cfxcore::pos::mempool::TransactionExclusion">Transaction<wbr>Exclusion</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ConsensusRequest.html" title="enum cfxcore::pos::mempool::ConsensusRequest">Consensus<wbr>Request</a></dt><dd>Message sent from consensus to mempool.</dd><dt><a class="enum" href="enum.ConsensusResponse.html" title="enum cfxcore::pos::mempool::ConsensusResponse">Consensus<wbr>Response</a></dt><dd>Response sent from mempool to consensus.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.bootstrap.html" title="fn cfxcore::pos::mempool::bootstrap">bootstrap</a></dt><dt><a class="fn" href="fn.gen_mempool_reconfig_subscription.html" title="fn cfxcore::pos::mempool::gen_mempool_reconfig_subscription">gen_<wbr>mempool_<wbr>reconfig_<wbr>subscription</a></dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.MempoolClientSender.html" title="type cfxcore::pos::mempool::MempoolClientSender">Mempool<wbr>Client<wbr>Sender</a></dt><dt><a class="type" href="type.SubmissionStatus.html" title="type cfxcore::pos::mempool::SubmissionStatus">Submission<wbr>Status</a></dt></dl></section></div></main></body></html>