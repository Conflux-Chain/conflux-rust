// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

use libra_types::crypto_proxies::ValidatorSet;
use serde::{Deserialize, Serialize};

/// A structure that summarizes the result of the execution needed for consensus
/// to agree on. The execution is responsible for generating the ID of the new
/// state, which is returned in the result.
///
/// Not every transaction in the payload succeeds: the returned vector keeps the
/// boolean status of success / failure of the transactions.
/// Note that the specific details of compute_status are opaque to
/// StateMachineReplication, which is going to simply pass the results between
/// StateComputer and TxnManager.
#[derive(Debug, Default, PartialEq, Eq, Clone)]
pub struct StateComputeResult {
    pub executed_state: ExecutedState,
    /* The compute status (success/failure) of the given payload. The
     * specific details are opaque for StateMachineReplication, which is
     * merely passing it between StateComputer and TxnManager.
     *pub compute_status: Vec<TransactionStatus>, */
}

impl StateComputeResult {
    /*
    pub fn version(&self) -> Version {
        self.executed_state.version
    }

    pub fn root_hash(&self) -> HashValue {
        self.executed_state.state_id
    }

    pub fn status(&self) -> &Vec<TransactionStatus> {
        &self.compute_status
    }
    */

    pub fn has_reconfiguration(&self) -> bool {
        self.executed_state.validators.is_some()
    }
}

/// Executed state derived from StateComputeResult that is maintained with every
/// proposed block. `state_id`(transaction accumulator root hash) summarized
/// both the information of the version and the validators.
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct ExecutedState {
    /// Tracks the execution state of a proposed block
    //pub state_id: HashValue,
    /// Version of after executing a proposed block.  This state must be
    /// persisted to ensure that on restart that the version is calculated
    /// correctly
    //pub version: Version,
    /// If set, this is the validator set that should be changed to if this
    /// block is committed. TODO [Reconfiguration] the validators are
    /// currently ignored, no reconfiguration yet.
    pub validators: Option<ValidatorSet>,
}

impl ExecutedState {
    pub fn state_for_genesis() -> Self {
        ExecutedState {
            //state_id: *ACCUMULATOR_PLACEHOLDER_HASH,
            //version: 0,
            validators: None,
        }
    }
}

/// Generated by processing VM's output.
#[derive(Debug, Clone)]
pub struct ProcessedVMOutput {
    /// The entire set of data associated with each transaction.
    //transaction_data: Vec<TransactionData>,

    /// The in-memory Merkle Accumulator and state Sparse Merkle Tree after
    /// appending all the transactions in this set.
    //executed_trees: ExecutedTrees,

    /// If set, this is the validator set that should be changed to if this
    /// block is committed. TODO [Reconfiguration] the validators are
    /// currently ignored, no reconfiguration yet.
    validators: Option<ValidatorSet>,
}

impl ProcessedVMOutput {
    pub fn new(
        //transaction_data: Vec<TransactionData>,
        //executed_trees: ExecutedTrees,
        validators: Option<ValidatorSet>,
    ) -> Self
    {
        ProcessedVMOutput {
            //transaction_data,
            //executed_trees,
            validators,
        }
    }

    /*
    pub fn transaction_data(&self) -> &[TransactionData] {
        &self.transaction_data
    }

    pub fn executed_trees(&self) -> &ExecutedTrees {
        &self.executed_trees
    }

    pub fn accu_root(&self) -> HashValue {
        self.executed_trees().txn_accumulator().root_hash()
    }

    pub fn version(&self) -> Option<Version> {
        self.executed_trees().version()
    }
    */

    pub fn validators(&self) -> &Option<ValidatorSet> { &self.validators }

    // This method should only be called by tests.
    pub fn set_validators(&mut self, validator_set: ValidatorSet) {
        self.validators = Some(validator_set)
    }

    pub fn state_compute_result(&self) -> StateComputeResult {
        //let num_leaves =
        // self.executed_trees().txn_accumulator().num_leaves();
        // let version = if num_leaves == 0 { 0 } else { num_leaves - 1 };
        StateComputeResult {
            // Now that we have the root hash and execution status we can send
            // the response to consensus.
            // TODO: The VM will support a special transaction to set the
            // validators for the next epoch that is part of a block
            // execution.
            executed_state: ExecutedState {
                //state_id: self.accu_root(),
                //version,
                validators: self.validators.clone(),
            },
            /*
            compute_status: self
                .transaction_data()
                .iter()
                .map(|txn_data| txn_data.status())
                .cloned()
                .collect(),
                */
        }
    }
}
