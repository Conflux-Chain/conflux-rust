// Copyright 2019 Conflux Foundation. All rights reserved.
// Conflux is free software and distributed under GNU General Public License.
// See http://www.gnu.org/licenses/

use crate::{bytes::Bytes, vm};
use cfx_types::{Address, U256, U512};
use primitives::{receipt::StorageChange, LogEntry, TransactionWithSignature};

#[derive(Debug, PartialEq, Clone)]
pub struct Executed {
    /// Gas used during execution of transaction.
    pub gas_used: U256,

    /// Fee that need to be paid by execution of this transaction.
    pub fee: U256,

    /// Gas charged during execution of transaction.
    pub gas_charged: U256,

    /// If the gas fee is born by designated sponsor.
    pub gas_sponsor_paid: bool,

    /// Vector of logs generated by transaction.
    pub logs: Vec<LogEntry>,

    /// If the storage cost is born by designated sponsor.
    pub storage_sponsor_paid: bool,

    /// Any accounts that occupy some storage.
    pub storage_collateralized: Vec<StorageChange>,

    /// Any accounts that release some storage.
    pub storage_released: Vec<StorageChange>,

    /// Addresses of contracts created during execution of transaction.
    /// Ordered from earliest creation.
    ///
    /// eg. sender creates contract A and A in constructor creates contract B
    ///
    /// B creation ends first, and it will be the first element of the vector.
    pub contracts_created: Vec<Address>,
    /// Transaction output.
    pub output: Bytes,
}

#[derive(Debug)]
pub enum ToRepackError {
    /// Returned when transaction nonce does not match state nonce.
    InvalidNonce {
        /// Nonce expected.
        expected: U256,
        /// Nonce found.
        got: U256,
    },

    /// Epoch height out of bound.
    /// The transaction was correct in the block where it's packed, but
    /// falls into the error when in the epoch to execute.
    EpochHeightOutOfBound {
        block_height: u64,
        set: u64,
        transaction_epoch_bound: u64,
    },

    /// Returned when cost of transaction (value + gas_price * gas) exceeds
    /// current sponsor balance.
    NotEnoughCashFromSponsor {
        /// Minimum required gas cost.
        required_gas_cost: U512,
        /// Actual balance of gas sponsor.
        gas_sponsor_balance: U512,
        /// Minimum required storage collateral cost.
        required_storage_cost: U256,
        /// Actual balance of storage sponsor.
        storage_sponsor_balance: U256,
    },

    /// Returned when a non-sponsored transaction's sender does not exist yet.
    SenderDoesNotExist,
}

#[derive(Debug)]
pub enum ExecutionError {
    /// Returned when cost of transaction (value + gas_price * gas) exceeds
    /// current sender balance.
    NotEnoughCash {
        /// Minimum required balance.
        required: U512,
        /// Actual balance.
        got: U512,
        /// Actual gas cost. This should be min(gas_fee, balance).
        actual_gas_cost: U256,
        /// Maximum storage limit cost.
        max_storage_limit_cost: U256,
    },
    /// Contract already exists in the specified address.
    ContractAddressConflict,
    VmError(vm::Error),
}

#[derive(Debug)]
pub enum ExecutionOutcome {
    NotExecutedOldNonce(U256, U256),
    NotExecutedToReconsiderPacking(ToRepackError),
    ExecutionErrorBumpNonce(ExecutionError, Executed),
    Finished(Executed),
}

impl ExecutionOutcome {
    pub fn successfully_executed(self) -> Option<Executed> {
        match self {
            ExecutionOutcome::Finished(executed) => Some(executed),
            _ => None,
        }
    }
}

impl Executed {
    pub fn not_enough_balance_fee_charged(
        tx: &TransactionWithSignature, fee: &U256,
    ) -> Self {
        let gas_charged = fee / tx.gas_price;
        Self {
            gas_used: tx.gas,
            gas_charged,
            fee: fee.clone(),
            gas_sponsor_paid: false,
            logs: vec![],
            contracts_created: vec![],
            storage_sponsor_paid: false,
            storage_collateralized: Vec::new(),
            storage_released: Vec::new(),
            output: Default::default(),
        }
    }

    pub fn execution_error_fully_charged(
        tx: &TransactionWithSignature,
    ) -> Self {
        Self {
            gas_used: tx.gas,
            gas_charged: tx.gas,
            fee: tx.gas * tx.gas_price,
            gas_sponsor_paid: false,
            logs: vec![],
            contracts_created: vec![],
            storage_sponsor_paid: false,
            storage_collateralized: Vec::new(),
            storage_released: Vec::new(),
            output: Default::default(),
        }
    }
}
