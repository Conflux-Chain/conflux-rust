searchState.loadedDescShard("network", 0, "Register a new protocol timer\nConnect to any address\nIP filter\nType of NAT resolving method\nBlock all addresses\nConnect to private network only\nConnect to public network only\nUser friendly session information that used for Debug RPC.\nTimer ID\nDirectory path to store general network configuration. …\nConnection lifetime threshold for promotion\nEnable discovery\nTimeout duration for refreshing discovery protocol when …\nPeriod between consecutive rounds of the same current …\nTimeout duration for refreshing discovery protocol when …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTimeout duration for initiating peer connection management\nNetwork identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIP filter\nMaximum number of ongoing handshakes\nMaximum number of incoming peers\nMaximum number of outgoing peers\nMaximum number of outgoing connections to archive nodes. 0 …\nEnable NAT configuration\nTimeout duration for persisting node table\nAttempt to parse the peer mode from a string.\nPacket header version of the peer.\nThere won’t be many protocols so it’s faster to use …\nIP address to advertise. Detected automatically if none.\nRegister a new IO timer. ‘IoHandler::timeout’ will be …\nList of reserved node addresses.\nMaximum number of P2P nodes for subnet B (ip/16).\nUse provided node key instead of default\nTimer delay.\nProtocol Id.\nProtocol Id.\nTimer token.\nWork type.\nA type for representing an interaction (contact) with a …\nNode address info\nNode public key\nNode table backed by disk file.\nIP(V4 or V6) address\nAttempt to connect to useless nodes again.\nCheck if a node exists in the table.\nOrdered list of all entries by failure percentage, for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate endpoint from string. Performs name resolution if …\nGet particular node\nGet particular node\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nValidates that the port is not 0 and address IP is …\nMark as useless, no further attempts to connect until next …\nReturns node ids sorted by failure percentage, for nodes …\nSet last contact as success for a node\nSet last contact as failure or demoted for a node\nReturn a random sample set of nodes inside the table\nSave the (un)trusted_nodes.json file.\nConnection port.\nCheck if node url is valid\nWrapper around network service.\nNetworkService implements the P2P communication between …\nThe inner implementation of NetworkService. Note that all …\nAdd a P2P peer to the client as a trusted node\nDrop a P2P peer from the client\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the current connected peers\nCreate and start the event loop inside the NetworkService\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOur private and public keys.\nGet the local address of the client\nLocal address + discovery port\nPublic address + discovery port\nRegister a new protocol handler\nMessage is sent through this method.\nSign a challenge to provide self NodeId\nExecutes action in the network context\nThrottling service is used to control the egress …\nValidate the throttling queue size for any data size …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the throttling ratio according to the current queue …\nInitialize the throttling service.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")