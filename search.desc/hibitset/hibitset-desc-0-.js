searchState.loadedDescShard("hibitset", 0, "hibitset\nThis is similar to a <code>BitSet</code> but allows setting of value …\nAn <code>Iterator</code> over a <code>BitSetLike</code> structure.\nA <code>ParallelIterator</code> over a <code>BitSetLike</code> structure.\nAllows splitting and internally iterating through <code>BitSet</code>.\nA <code>BitSet</code> is a simple set designed to track which indices …\n<code>BitSetAll</code> is a bitset with all bits set. Essentially the …\n<code>BitSetAnd</code> takes two <code>BitSetLike</code> items, and merges the masks …\nA generic interface for <code>BitSetLike</code>-like types.\n<code>BitSetNot</code> takes a <code>BitSetLike</code> item, and produced an …\n<code>BitSetOr</code> takes two <code>BitSetLike</code> items, and merges the masks …\n<code>BitSetXor</code> takes two <code>BitSetLike</code> items, and merges the masks …\nA draining <code>Iterator</code> over a <code>DrainableBitSet</code> structure.\nA extension to the <code>BitSetLike</code> trait which allows draining …\nAdds <code>id</code> to the <code>BitSet</code>. Returns <code>true</code> if the value was …\nAdds <code>id</code> to the <code>BitSet</code>. Returns <code>true</code> if the value was …\nAdds <code>id</code> to the <code>AtomicBitSet</code>. Returns <code>true</code> if the value was …\nClear all bits in the set\nCompletely wipes out the bit set.\nAllows checking if set bit is contained in the bit set.\nReturns <code>true</code> if <code>id</code> is in the set.\nAllows checking if set bit is contained in underlying bit …\nReturns <code>true</code> if <code>id</code> is in the set.\nReturns <code>true</code> if all ids in <code>other</code> are contained in this set\nCreate a draining iterator that will scan over the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the <code>usize</code> corresponding to layer and index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this <code>BitSetLike</code> contains nothing, and …\nCreate an iterator that will scan over the keyspace\nReturn a <code>usize</code> that maps to the direct 1:1 association with\nReturn the <code>usize</code> from the array of usizes that indicates …\nReturn the <code>usize</code> from the array of usizes that indicates …\nReturn a <code>usize</code> where each bit represents if any word in …\nSets how many layers are split when forking.\nReturn the number of elements\nCreates a new <code>DrainBitIter</code>. You usually don’t call this …\nCreates an empty <code>AtomicBitSet</code>.\nCreates a new <code>BitParIter</code>. You usually don’t call this …\nCreates a new <code>BitIter</code>. You usually don’t call this …\nCreates an empty <code>BitSet</code>.\nCreate a parallel iterator that will scan over the keyspace\nRemoves bit from the bit set.\nRemoves <code>id</code> from the set, returns <code>true</code> if the value was …\nRemoves <code>id</code> from the set, returns <code>true</code> if the value was …\nHow the splitting is done:\nCreates an empty <code>BitSet</code>, preallocated for up to <code>max</code> …")