searchState.loadedDescShard("safety_rules", 0, "Public representation of the internal state of SafetyRules …\nDifferent reasons for proposal rejection\nSafetyRules needs an abstract storage interface to act as …\n@TODO consider a cache of verified QCs to cut down on …\nInterface for SafetyRules\nProvides the internal state of SafetyRules for monitoring …\nAttempts to vote for a given proposal following the voting …\nProduces a LedgerInfo that either commits a block based …\nReturns the current epoch\nCheck if the executed result extends the parent result.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIndicating whether the validator is validator set\nInitialize SafetyRules using an Epoch ending LedgerInfo, …\nUse this to instantiate a PersistentStorage for a new data …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the last round that was voted on\nConstructs a new instance of SafetyRules with the given …\nA “preferred block” is the two-chain head with the …\nReturn a copy of the safety data.\nAs the holder of the private key, SafetyRules also signs …\nAs the holder of the private key, SafetyRules also signs …\nAllow the safety rule to start voting with saved secure …\nAllow the safety rule to start voting with saved secure …\nStop the safety rule from voting and save secure data.\nStop the safety rule from voting and save secure data.\nLast known checkpoint this should map to a LedgerInfo that …")