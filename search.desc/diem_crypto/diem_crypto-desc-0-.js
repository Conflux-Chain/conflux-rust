searchState.loadedDescShard("diem_crypto", 0, "This feature gets turned on only if diem-crypto is …\nA BLS signature wrapper\nWrapper structs for types that need RustCrypto traits …\nA Elliptic Curve VRF wrapper\nThis module provides an API for the PureEdDSA signature …\nRexport the error types needed for the various crypto …\nThis module defines traits and implementations of …\nAn implementation of HKDF, the HMAC-based …\nUtility to store encrypted private keys\nA multi bls signature wrapper\nThis module provides an API for the accountable threshold …\nNoise is a protocol framework which we use in Diem to …\nInternal module containing convenience utility functions …\nThis module provides a generic set of traits for dealing …\nVDF SHA256.\nAn abstraction of x25519 elliptic curve keys required for …\nBLS signature private key\nBLS signature public key\nUsed to deserialize keys in local storage whose validity …\nBLS signature wrapper\nUsed to deserialize keys in local storage whose validity …\nPrivate key length in bytes. The actual key length should …\nPublic key length in bytes.\nSignature length in bytes.\nDeserialize public key from local storage.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturn raw public key\nreturn raw signature\nDeserialize an BLSPrivateKey. This method will also check …\nDeserialize an BLSPrivateKey. This method will also check …\nDeserialize an BLSPrivateKey. This method will also check …\nDeserialize an BLSPrivateKey. This method will also check …\nDeserialize an BLSPrivateKey. This method will also check …\nA wrapper for <code>tiny_keccak::Sha3::v256</code> that implements …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nElliptic Curve VRF private key\nElliptic Curve VRF proof\nElliptic Curve VRF public key\nVRF Cipher context. Mutex is needed because functions …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDeserialize an EcVrfPrivateKey. This method will also …\nDeserialize an EcVrfPrivateKey. This method will also …\nDeserialize an EcVrfPrivateKey. This method will also …\nThe length of the Ed25519PrivateKey\nThe length of the Ed25519PublicKey\nThe length of the Ed25519Signature\nAn Ed25519 private key\nAn Ed25519 public key\nAn Ed25519 signature\nThe length of the Ed25519PrivateKey\nThe length of the Ed25519Signature\nCheck for correct size and third-party based signature …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSerialize an Ed25519PrivateKey.\nSerialize an Ed25519PublicKey.\nSerialize an Ed25519Signature.\nDeserialize an Ed25519PrivateKey. This method will also …\nDeserialize an Ed25519PublicKey. This method will also …\nVerifies that the provided signature is valid for the …\nChecks that <code>self</code> is valid for an arbitrary &amp;u8 <code>message</code> …\nThe <code>Error</code> type, a wrapper around a dynamic error type.\nGet the backtrace for this Error.\nReturn early with an error.\nAn iterator of the chain of source errors contained by …\nWrap the error value with additional context.\nAttempt to downcast the error object to a concrete type.\nDowncast this error object by mutable reference.\nDowncast this error object by reference.\nReturns the argument unchanged.\nConstruct an error object from a type-erased standard …\nCalls <code>U::from(self)</code>.\nConvert to a standard library error trait object.\nReturns true if <code>E</code> is the type held by this error object.\nCreate a new error object from a printable error message.\nCreate a new error object from any error type.\nConvert to a standard library error trait object.\nThe lowest level cause of this error — this error’s …\nPlaceholder hash of <code>Accumulator</code>.\nA type that can be cryptographically hashed to produce a …\nA trait for representing the state of a cryptographic …\nThe hasher used to compute the hash of an internal node in …\nGenesis block id is used as a parent of the very first …\nOutput value of our hash function. Intentionally opaque …\nAn iterator over <code>HashValue</code> that generates one bit for each …\nParse error when attempting to construct a HashValue\nThe associated <code>Hasher</code> type which comes with a unique salt …\nThe length of the hash in bytes.\nThe length of the hash in bits.\nBlock id reserved as the id of parent block of the genesis …\nPlaceholder hash of <code>SparseMerkleTree</code>.\nThe hasher used to compute the hash of an internal node in …\nProvides a test_only_hash() method that can be used in …\nThe hasher used only for testing. It doesn’t have a salt.\nThe hasher used to compute the hash of an internal node in …\nThe hasher used to compute the hash of an internal node in …\nReturns the length of common prefix of <code>self</code> and <code>other</code> in …\nFinish constructing the <code>HashValue</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>HashValue</code> from an iterator of bits.\nParse a given hex string to a hash value.\nCreate from a slice (e.g. retrieved from storage).\nHashes the object and produces a <code>HashValue</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a <code>HashValueBitIterator</code> over all the bits that …\nCreate a new <code>HashValue</code> from a byte array.\nCreate a cryptographically random instance.\nCreates a random instance with given rng. Useful in unit …\nthe seed used to initialize hashing <code>Self</code> before the …\nConvenience function that computes a <code>HashValue</code> internally …\nGenerates a hash used only for tests.\nFull hex representation of a given hash value.\nConvert a hash to big int (U256).\nDumps into a vector.\nWrite bytes into the hasher.\nCreates a zero-initialized instance.\nStructure representing the HKDF, capable of HKDF-Extract …\nAn error type for HKDF key derivation issues.\nHKDF expand output exceeds the maximum allowed or is zero.\nHMAC key related error; unlikely to happen because every …\nPRK on HKDF-Expand should not be less than the underlying …\nThe RFC5869 HKDF-Expand operation.\nThe RFC5869 HKDF-Extract operation.\nHKDF Extract then Expand operation as a single step.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad <code>passwd</code> encrypted private key from <code>path</code>.\nEncrypt <code>pri_key</code> with <code>passwd</code>, and save it to <code>path</code>.\nVector of private keys in the multi-key BLS structure.\nVector of public keys in the multi-key BLS structure.\nMulti BLS signature wrapper\nAggregate signatures by multiplying them together. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRecreate the key from bytes in the same form as <code>write_bytes</code>…\nDeserializes a private key from the field element as a …\nGenerate a new private key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerate a deterministic private key from the given bytes.\nConstruct a new MultiBLSPrivateKey.\nConstruct a new MultiBLSPublicKey.\nThis method will also sort signatures based on index.\nGet the public key for this private key. Calculated by …\nGetter public_keys\nGetter raw signature.\nSign the given message. Calculated by …\nSerialize a MultiBLSPrivateKey.\nSerialize a MultiBLSPublicKey.\nto bytes\nDeserialize an BLSPrivateKey. This method will also check …\nDeserialize a MultiBLSPublicKey. This method will also …\nDeserialize a MultiBLSSignature. This method will also …\nChecks that <code>self</code> is valid for an arbitrary &amp;u8 <code>message</code> …\nWrites the key to the given writer.\nVector of private keys in the multi-key Ed25519 structure …\nVector of public keys in the multi-key Ed25519 structure …\nVector of the multi-key signatures along with a 32bit [u8; …\nGetter bitmap.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new MultiEd25519PrivateKey.\nConstruct a new MultiEd25519PublicKey. — Rules — a) …\nThis method will also sort signatures based on index.\nGetter public_keys\nGetter signatures.\nGetter threshold\nSerialize a MultiEd25519PrivateKey.\nSerialize a MultiEd25519PublicKey.\nSerialize a MultiEd25519Signature in the form of …\nDeserialize an Ed25519PrivateKey. This method will also …\nDeserialize a MultiEd25519PublicKey. This method will also …\nDeserialize a MultiEd25519Signature. This method will also …\nChecks that <code>self</code> is valid for an arbitrary &amp;u8 <code>message</code> …\nThe authentication tag length of AES-GCM.\ncould not decrypt the received data (most likely the data …\nencryption has failed (in practice there is no reason for …\nHKDF has failed (in practice there is no reason for HKDF …\nRefer to the Noise protocol framework specification in …\nA noise message cannot be larger than 65535 bytes as per …\nthe received message is too short to contain the expected …\nA key holder structure used for both initiators and …\nA NoiseError enum represents the different types of error …\nA NoiseSession is produced after a successful Noise …\nthe nonce exceeds the maximum u64 value (in practice this …\nthe payload that we are trying to send is too large\nthe message we received is too large\nRefer to the Noise protocol framework specification in …\nthe response buffer passed as argument is too small\nsession was closed due to decrypt error\nthe public key received is of the wrong format\nA handy const fn to get the size of a plaintext from a …\nA handy const fn to get the expanded size of a plaintext …\nA client can call this to finalize a connection, after …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nobtain remote static public key\nA handy const fn to get the size of the first handshake …\nA handy const fn to get the size of the second handshake …\nAn initiator can use this function to initiate a handshake …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA peer must create a NoiseConfig through this function …\nA responder can accept a connection by first parsing an …\nHandy getter to access the configuration’s public key\ndecrypts a message from the other peer (post-handshake) …\nA responder can respond to an initiator by calling this …\nThis function is a one-call that replaces calling the two …\nencrypts a message for the other peers (post-handshake) …\nA keypair consisting of a private and public key\nA deterministic seed for PRNGs related to keys\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nthe private key component\nthe public key component\nbls aggerate error\nBitVec errors in accountable multi-sig schemes.\nPart of the signature or key is not canonical resulting to …\nAn error type for key and signature validation issues, see …\nKey or signature material does not deserialize correctly.\nA type family with a by-convention notion of genesis …\nThe serialized length of the data that enables macro …\nA curve point (i.e., a public key) does not satisfy the …\nA type family for key material that should remain secret …\nWe require public / private types to be coupled, i.e. their\nThe associated private key type for this public key.\nThe associated private key type for this proof.\nThe associated proof type for this public key.\nThe associated proof type for this private key.\nA type for key material that can be publicly shared, and …\nWe require public / private types to be coupled, i.e. their\nThe associated public key type for this private key.\nThe associated public key type for this proof.\nStruct to be signed does not serialize correctly.\nA type family for signature material that knows which …\nThe associated signature type for this signing key.\nThe associated signature type for this verifying key.\nA type family of valid keys that know how to sign.\nThe associated signing key type for this verifying key.\nThe associated signing key type for this signature\nA curve point (i.e., a public key) lies on a small group.\nA type family for schemes which know how to generate key …\nPrivate key for VRF\nThe proof of VRF\nPublic key for VRF\nKey or more generally crypto material with a notion of …\nAn extension to to/from Strings for <code>ValidCryptoMaterial</code>.\nKey or signature material deserializes, but is otherwise …\nThe trait for VDF.\nA type family of public keys that are used for signing.\nThe associated verifying key type for this signing key.\nThe associated verifying key type for this signature.\nKey, threshold or signature material does not have the …\nWe provide the implementation which dispatches to the …\nThe implementer can override a batch verification …\nGenerate a random number (hash) with a proof for …\nReturns the argument unchanged.\nWhen trying to convert from bytes, we simply decode the …\nGenerate key material from an RNG. This should generally …\nGenerate a random key using the shared TEST_SEED\nProduces the genesis private key.\nCalls <code>U::from(self)</code>.\nThe serialized length of the data\nReturns the associated public key\nSigns an object that has an distinct domain-separation …\nsolve inputted <code>challenge</code> with a given <code>difficulty</code>, and …\nConvert the valid crypto material to bytes.\nA function to encode into hex-string after serializing.\nConvert the proof to a verifiable random number (hash).\nVerification for a struct we unabmiguously know how to …\nVerify if the proof is generated from <code>seed</code> by the private …\nVerify that the given <code>alleged_solution</code> is indeed a valid …\nNative verification function.\nVerify if <code>proof</code> if generated from <code>seed</code> by the private key …\nWe provide the striaghtfoward implementation which …\nReturns the associated verifying key\nHash the vrf output and a nonce within the proposer’s …\nVDF SHA256.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSize of a X25519 private key\nSize of a X25519 public key\nThis type should be used to deserialize a received private …\nThis type should be used to deserialize a received public …\nSize of a X25519 shared secret\nObtain a slice reference to the underlying bytearray\nTo perform a key exchange with another public key\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize an X25119 PrivateKey given the sha512 …\nDeserialize an X25119 PublicKey from its representation as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nObtain the public key part of a private key")