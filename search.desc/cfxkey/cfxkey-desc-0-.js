searchState.loadedDescShard("cfxkey", 0, "Simple brainwallet.\nTries to find brain-seed keypair with address starting …\nCustom\nKey derivation over generic label <code>T</code>\nCrypto error\nExtended public key, allows deterministic derivation of …\nExtended secret key, allows deterministic derivation of …\nHard key derivation (does not allow proof of parent)\nInvalid address\nInvalid AES message\nInvalid public key\nInvalid secret key\nInvalid EC signature\nInvalid y-parity\nIO Error\nsecp256k1 key pair\nGenerates new keypair.\nPhrase is shorter than it was expected.\nTries to find keypair with address starting with given …\nRandomly generates new keypair, instantiating the RNG each …\nSignature encoded as RSV components\nSoft key derivation (allow proof of parent)\nUninstantiatable error type for infallible generators.\nPhrase contains a word that doesn’t come from our …\nPhrase Validation Error\nInplace add one secret key to another (scalar + scalar)\nPrivate key component of the extended key.\nChecks validity of this key.\nInplace decrease secret key (scalar - 1)\nDerive new private key\nDerive new public key Operation is defined only for index …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse bytes as a signature encoded as RSV (V in “Electrum…\nCreate a signature object from the sig.\nCreate new extended public key from known secret\nCreate a pair from secret key\nCreates a <code>Secret</code> from the given slice, returning <code>None</code> if …\nImports and validates the key.\nShould be called to generate new keypair.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncode the signature into RSV array (V altered to be in “…\nInplace inverse secret key (1 / scalar)\nCheck if the recovered address started with 0x1. If it …\nCheck if this is a “low” signature.\nCheck if each component of the signature is in range.\nInplace multiply one secret key to another (scalar * …\nInplace negate secret key (-scalar)\nNew extended key from given secret. Chain code will be …\nNew extended public key from known parent and chain code\nNew extended key from given secret with the random chain …\nCompute power of secret key inplace (secret ^ pow). This …\nGet a slice into the ‘r’ portion of the data.\nGet a slice into the ‘s’ portion of the data.\nInplace subtract one secret key from another (scalar - …\nCreate <code>secp256k1::key::SecretKey</code> based on this secret\nGet the recovery byte.\nNew extended key from given secret and chain code.\nCreates zero key, which is invalid for crypto operations, …\nIterator over possible\nTries to find a phrase for address, given the number of …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nECDH functions\nECIES function\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAgree on a shared secret\nDecrypt a message with a secret key, checking HMAC for …\nEncrypt a message with a public key, writing an HMAC …\nReturn secp256k1 elliptic curve order\nReturn base point of secp256k1\nInplace add one public key to another (EC point + EC point)\nWhether the public key is valid.\nInplace multiply public key by secret key (EC point * …\nReplace public key with its negation (EC point = - EC …\nInplace sub one public key from another (EC point - EC …")