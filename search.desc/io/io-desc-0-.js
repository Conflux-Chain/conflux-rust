searchState.loadedDescShard("io", 0, "General IO module.\nRegister a new protocol handler.\nAllows sending messages into the event loop. All the IO …\nIO access point. This is passed to all IO handlers and …\nIO Error\nGeneric IO handler. All the handler function are called …\nRoot IO handler. Manages user handlers, messages and IO …\nMessages used to communicate with the event loop from …\nGeneral IO Service. Starts an event loop and dispatches IO …\nStack size Should be modified if it is changed in Rust …\nHandle a message received from a peer by a specified …\nShutdown the event loop\nError concerning the Rust standard library’s IO …\nStream ID\nMaximum number of tokens a handler can use\nTimer ID\nBroadcast a message across all protocol handlers.\nCreate a new message channel\nGet message channel\nDelete a timer.\nDeregister a stream. Called when stream is removed from …\nDeregister an IO stream.\nCreate a new channel disconnected from an event loop.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize the handler\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalled when a broadcasted message is received. The message …\nBroadcast a message to other IO clients\nCreate a new IO access point. Takes references to all the …\nRegister an IO handler with the event loop.\nRegister a new stream with the event loop\nRegister a new IO stream.\nRegister a new recurring IO timer. ‘IoHandler::timeout’…\nRegister a new IO timer once. ‘IoHandler::timeout’ …\nRegister a new IO timer once. ‘IoHandler::timeout’ …\nSend a message through the channel\nSend low level io message\nSend a message over the network. Normally <code>HostIo::send</code> …\nSend a message through the channel and handle it …\nCreates a new instance and registers it with the event …\nStarts IO event loop\nCalled when an IO stream gets closed\nCalled when an IO stream can be read from\nCalled when an IO stream can be written to\nTimer function called after a timeout created with …\nCreate a new synchronous channel to a given handler.\nUnregister current IO handler.\nReregister an IO stream.\nRe-register a stream with the event loop\nsame as UserTimer.cancel_all")