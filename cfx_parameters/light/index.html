<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `light` mod in crate `cfx_parameters`."><title>cfx_parameters::light - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="cfx_parameters" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (854f22563 2025-01-31)" data-channel="nightly" data-search-js="search-2d513d54.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-302de22f.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-9b5d7e41.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../cfx_parameters/index.html">cfx_<wbr>parameters</a><span class="version">1.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module light</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate cfx_<wbr>parameters</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">cfx_parameters</a></div><h1>Module <span>light</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/cfx_parameters/lib.rs.html#356">Source</a> </span></div><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BLOCK_TX_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::BLOCK_TX_REQUEST_TIMEOUT">BLOCK_<wbr>TX_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.BLOOM_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::BLOOM_REQUEST_TIMEOUT">BLOOM_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.CACHE_TIMEOUT.html" title="struct cfx_parameters::light::CACHE_TIMEOUT">CACHE_<wbr>TIMEOUT</a></dt><dd>Items not accessed for this amount of time are removed from the cache.</dd><dt><a class="struct" href="struct.CLEANUP_PERIOD.html" title="struct cfx_parameters::light::CLEANUP_PERIOD">CLEANUP_<wbr>PERIOD</a></dt><dd>Frequency of checking request timeouts.</dd><dt><a class="struct" href="struct.EPOCH_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::EPOCH_REQUEST_TIMEOUT">EPOCH_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dd>Request timeouts.</dd><dt><a class="struct" href="struct.HEADER_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::HEADER_REQUEST_TIMEOUT">HEADER_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.HEARTBEAT_PERIOD.html" title="struct cfx_parameters::light::HEARTBEAT_PERIOD">HEARTBEAT_<wbr>PERIOD</a></dt><dd>Frequency of sending StatusPing message to peers.</dd><dt><a class="struct" href="struct.MAX_POLL_TIME.html" title="struct cfx_parameters::light::MAX_POLL_TIME">MAX_<wbr>POLL_<wbr>TIME</a></dt><dd>Maximum time period we wait for a response for an on-demand query.
After this timeout has been reached, we try another peer or give up.</dd><dt><a class="struct" href="struct.RECEIPT_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::RECEIPT_REQUEST_TIMEOUT">RECEIPT_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.STATE_ENTRY_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::STATE_ENTRY_REQUEST_TIMEOUT">STATE_<wbr>ENTRY_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.STATE_ROOT_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::STATE_ROOT_REQUEST_TIMEOUT">STATE_<wbr>ROOT_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.STORAGE_ROOT_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::STORAGE_ROOT_REQUEST_TIMEOUT">STORAGE_<wbr>ROOT_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.SYNC_PERIOD.html" title="struct cfx_parameters::light::SYNC_PERIOD">SYNC_<wbr>PERIOD</a></dt><dd>Frequency of re-triggering sync.</dd><dt><a class="struct" href="struct.TX_INFO_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::TX_INFO_REQUEST_TIMEOUT">TX_<wbr>INFO_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.TX_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::TX_REQUEST_TIMEOUT">TX_<wbr>REQUEST_<wbr>TIMEOUT</a></dt><dt><a class="struct" href="struct.WITNESS_REQUEST_TIMEOUT.html" title="struct cfx_parameters::light::WITNESS_REQUEST_TIMEOUT">WITNESS_<wbr>REQUEST_<wbr>TIMEOUT</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.BLAME_CHECK_OFFSET.html" title="constant cfx_parameters::light::BLAME_CHECK_OFFSET">BLAME_<wbr>CHECK_<wbr>OFFSET</a></dt><dd>During syncing, we might transiently have enough malicious blaming
blocks to consider a correct header incorrect. For this reason, we
first wait for enough header to accumulate before checking blaming.
TODO(thegaram): review value and expose this as a parameter</dd><dt><a class="constant" href="constant.BLOCK_TX_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::BLOCK_TX_REQUEST_BATCH_SIZE">BLOCK_<wbr>TX_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.BLOOM_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::BLOOM_REQUEST_BATCH_SIZE">BLOOM_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.CATCH_UP_EPOCH_LAG_THRESHOLD.html" title="constant cfx_parameters::light::CATCH_UP_EPOCH_LAG_THRESHOLD">CATCH_<wbr>UP_<wbr>EPOCH_<wbr>LAG_<wbr>THRESHOLD</a></dt><dd>The threshold controlling whether a node is in catch-up mode.
A node is in catch-up mode if its local best epoch number is
<code>CATCH_UP_EPOCH_LAG_THRESHOLD</code> behind the median of the epoch
numbers of peers.</dd><dt><a class="constant" href="constant.EPOCH_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::EPOCH_REQUEST_BATCH_SIZE">EPOCH_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dd>(Maximum) number of items requested in a single request.</dd><dt><a class="constant" href="constant.GAS_PRICE_BATCH_SIZE.html" title="constant cfx_parameters::light::GAS_PRICE_BATCH_SIZE">GAS_<wbr>PRICE_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.GAS_PRICE_BLOCK_SAMPLE_SIZE.html" title="constant cfx_parameters::light::GAS_PRICE_BLOCK_SAMPLE_SIZE">GAS_<wbr>PRICE_<wbr>BLOCK_<wbr>SAMPLE_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.GAS_PRICE_TRANSACTION_SAMPLE_SIZE.html" title="constant cfx_parameters::light::GAS_PRICE_TRANSACTION_SAMPLE_SIZE">GAS_<wbr>PRICE_<wbr>TRANSACTION_<wbr>SAMPLE_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.HEADER_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::HEADER_REQUEST_BATCH_SIZE">HEADER_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.LOG_FILTERING_LOOKAHEAD.html" title="constant cfx_parameters::light::LOG_FILTERING_LOOKAHEAD">LOG_<wbr>FILTERING_<wbr>LOOKAHEAD</a></dt><dd>During log filtering, we stream a set of items (blooms, receipts, txs)
to match against. To make the process faster, we need to make sure that
there’s always plenty of items in flight. This way, we can reduce idle
time when we’re waiting to receive an item.</dd><dt><a class="constant" href="constant.MAX_BLOCK_TXS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_BLOCK_TXS_IN_FLIGHT">MAX_<wbr>BLOCK_<wbr>TXS_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_BLOOMS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_BLOOMS_IN_FLIGHT">MAX_<wbr>BLOOMS_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_EPOCHS_TO_SEND.html" title="constant cfx_parameters::light::MAX_EPOCHS_TO_SEND">MAX_<wbr>EPOCHS_<wbr>TO_<wbr>SEND</a></dt><dd>Max number of epochs/headers/txs to send to a light peer in a response.</dd><dt><a class="constant" href="constant.MAX_HEADERS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_HEADERS_IN_FLIGHT">MAX_<wbr>HEADERS_<wbr>IN_<wbr>FLIGHT</a></dt><dd>Maximum number of in-flight items at any given time.
If we reach this limit, we will not request any more.</dd><dt><a class="constant" href="constant.MAX_HEADERS_TO_SEND.html" title="constant cfx_parameters::light::MAX_HEADERS_TO_SEND">MAX_<wbr>HEADERS_<wbr>TO_<wbr>SEND</a></dt><dt><a class="constant" href="constant.MAX_ITEMS_TO_SEND.html" title="constant cfx_parameters::light::MAX_ITEMS_TO_SEND">MAX_<wbr>ITEMS_<wbr>TO_<wbr>SEND</a></dt><dt><a class="constant" href="constant.MAX_PARALLEL_EPOCH_REQUESTS.html" title="constant cfx_parameters::light::MAX_PARALLEL_EPOCH_REQUESTS">MAX_<wbr>PARALLEL_<wbr>EPOCH_<wbr>REQUESTS</a></dt><dd>Maximum number of in-flight epoch requests at any given time.
Similar to <code>MAX_HEADERS_IN_FLIGHT</code>. However, it is hard to match
hash responses to epoch requests, so we count the requests instead.</dd><dt><a class="constant" href="constant.MAX_RECEIPTS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_RECEIPTS_IN_FLIGHT">MAX_<wbr>RECEIPTS_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_STATE_ENTRIES_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_STATE_ENTRIES_IN_FLIGHT">MAX_<wbr>STATE_<wbr>ENTRIES_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_STATE_ROOTS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_STATE_ROOTS_IN_FLIGHT">MAX_<wbr>STATE_<wbr>ROOTS_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_STORAGE_ROOTS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_STORAGE_ROOTS_IN_FLIGHT">MAX_<wbr>STORAGE_<wbr>ROOTS_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_TXS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_TXS_IN_FLIGHT">MAX_<wbr>TXS_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_TXS_TO_SEND.html" title="constant cfx_parameters::light::MAX_TXS_TO_SEND">MAX_<wbr>TXS_<wbr>TO_<wbr>SEND</a></dt><dt><a class="constant" href="constant.MAX_TX_INFOS_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_TX_INFOS_IN_FLIGHT">MAX_<wbr>TX_<wbr>INFOS_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_WITNESSES_IN_FLIGHT.html" title="constant cfx_parameters::light::MAX_WITNESSES_IN_FLIGHT">MAX_<wbr>WITNESSES_<wbr>IN_<wbr>FLIGHT</a></dt><dt><a class="constant" href="constant.MAX_WITNESSES_TO_SEND.html" title="constant cfx_parameters::light::MAX_WITNESSES_TO_SEND">MAX_<wbr>WITNESSES_<wbr>TO_<wbr>SEND</a></dt><dt><a class="constant" href="constant.NUM_EPOCHS_TO_REQUEST.html" title="constant cfx_parameters::light::NUM_EPOCHS_TO_REQUEST">NUM_<wbr>EPOCHS_<wbr>TO_<wbr>REQUEST</a></dt><dd>Number of epochs to request in one round (in possibly multiple batches).</dd><dt><a class="constant" href="constant.NUM_WAITING_HEADERS_THRESHOLD.html" title="constant cfx_parameters::light::NUM_WAITING_HEADERS_THRESHOLD">NUM_<wbr>WAITING_<wbr>HEADERS_<wbr>THRESHOLD</a></dt><dd>Minimum number of missing items in the sync pipeline.
If we have fewer, we will try to request some more.</dd><dt><a class="constant" href="constant.RECEIPT_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::RECEIPT_REQUEST_BATCH_SIZE">RECEIPT_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.STATE_ENTRY_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::STATE_ENTRY_REQUEST_BATCH_SIZE">STATE_<wbr>ENTRY_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.STATE_ROOT_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::STATE_ROOT_REQUEST_BATCH_SIZE">STATE_<wbr>ROOT_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.STORAGE_ROOT_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::STORAGE_ROOT_REQUEST_BATCH_SIZE">STORAGE_<wbr>ROOT_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.TRANSACTION_COUNT_PER_BLOCK_WATER_LINE_LOW.html" title="constant cfx_parameters::light::TRANSACTION_COUNT_PER_BLOCK_WATER_LINE_LOW">TRANSACTION_<wbr>COUNT_<wbr>PER_<wbr>BLOCK_<wbr>WATER_<wbr>LINE_<wbr>LOW</a></dt><dt><a class="constant" href="constant.TRANSACTION_COUNT_PER_BLOCK_WATER_LINE_MEDIUM.html" title="constant cfx_parameters::light::TRANSACTION_COUNT_PER_BLOCK_WATER_LINE_MEDIUM">TRANSACTION_<wbr>COUNT_<wbr>PER_<wbr>BLOCK_<wbr>WATER_<wbr>LINE_<wbr>MEDIUM</a></dt><dt><a class="constant" href="constant.TX_INFO_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::TX_INFO_REQUEST_BATCH_SIZE">TX_<wbr>INFO_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.TX_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::TX_REQUEST_BATCH_SIZE">TX_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.WITNESS_REQUEST_BATCH_SIZE.html" title="constant cfx_parameters::light::WITNESS_REQUEST_BATCH_SIZE">WITNESS_<wbr>REQUEST_<wbr>BATCH_<wbr>SIZE</a></dt></dl></section></div></main></body></html>